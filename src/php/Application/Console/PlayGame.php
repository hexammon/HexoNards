<?php
declare(strict_types=1);


namespace Hexammon\HexoNards\Application\Console;

use Hexammon\HexoNards\Board\Board;
use Hexammon\HexoNards\Board\BoardBuilder;
use Hexammon\HexoNards\Game\Action\MoveArmy;
use Hexammon\HexoNards\Game\Action\ReplenishGarrison;
use Hexammon\HexoNards\Game\Game;
use Hexammon\HexoNards\Game\PlayerInterface;
use Hexammon\HexoNards\Game\Rules\ClassicRuleSet;
use SebastianBergmann\CodeCoverage\Report\PHP;
use Symfony\Component\Console\Command\Command;
use Symfony\Component\Console\Cursor;
use Symfony\Component\Console\Helper\QuestionHelper;
use Symfony\Component\Console\Input\InputArgument;
use Symfony\Component\Console\Input\InputInterface;
use Symfony\Component\Console\Input\InputOption;
use Symfony\Component\Console\Output\OutputInterface;
use Symfony\Component\Console\Question\ChoiceQuestion;
use Symfony\Component\Console\Question\ConfirmationQuestion;
use Symfony\Component\Console\Question\Question;

class PlayGame extends Command
{

    private const NUMBER_OF_PLAYERS = 'players';
    private const NUMBER_OF_ROWS    = 'rows';
    private const NUMBER_OF_COLS    = 'cols';

    private const DEFAULT_PLAYERS = 2;
    private const DEFAULT_ROWS    = 8;
    private const DEFAULT_COLS    = 8;

    protected function configure()
    {
        $this->addOption(self::NUMBER_OF_PLAYERS, 'p', InputOption::VALUE_OPTIONAL, 'number of players', self::DEFAULT_PLAYERS);
        $this->addOption(self::NUMBER_OF_ROWS, 'r', InputOption::VALUE_OPTIONAL, 'number of rows', self::DEFAULT_ROWS);
        $this->addOption(self::NUMBER_OF_COLS, 'c', InputOption::VALUE_OPTIONAL, 'number of columns', self::DEFAULT_COLS);
        parent::configure(); // TODO: Change the autogenerated stub
    }

    public function execute(InputInterface $input, OutputInterface $output)
    {
        /**@var QuestionHelper $questionHelper */
        $questionHelper = $this->getHelper('question');

        $numberOfPlayers = (int)$input->getOption(self::NUMBER_OF_PLAYERS) ?: self::DEFAULT_PLAYERS;
//        $playersQuestion = new Question('How many players will play the game? [' . $numberOfPlayers . ']' . PHP_EOL, $numberOfPlayers);
//        $numberOfPlayers = (int)$questionHelper->ask($input, $output, $playersQuestion);

        $rows = (int)$input->getOption(self::NUMBER_OF_ROWS) ?: self::DEFAULT_ROWS;
//        $rowsQuestion = new Question('Enter rows size of board for the game [' . $rows . ']' . PHP_EOL, $rows);
//        $rows = (int)$questionHelper->ask($input, $output, $rowsQuestion);

        $cols = (int)$input->getOption(self::NUMBER_OF_COLS) ?: self::DEFAULT_COLS;
//        $colsQuestion = new Question('Enter columns size of board for the game [' . $cols . ']' . PHP_EOL, $cols);
//        $cols = (int)$questionHelper->ask($input, $output, $colsQuestion);

        $players = [];
        for ($number = 1; $number++ <= $numberOfPlayers;) {
            $players[] = new NumberedPlayer($number);
        }

        $boardBuilder = new BoardBuilder();
        $board = $boardBuilder->build(Board::TYPE_SQUARE, $rows, $cols);

        $game = new Game($players, $board);

        $ruleSet = new ClassicRuleSet();
        $ruleSet->getInitialSetting()->arrangePieces($game);

        $this->outputBoard($board, $output);

        while (!$ruleSet->isGameOver($game)) {
            $this->doNextMove($game, $output, $input);
            $this->outputBoard($board, $output);
        }

        return 0;
    }

    private function outputBoard(Board $board, OutputInterface $output)
    {
        $cols = $board->getColumns();
        $rowBorder = str_pad('_____', count($cols) * 7, '_');

        $output->write('     |');
        foreach ($cols as $column) {
            $columnsHeader = sprintf('%s|', str_pad((string)$column->getNumber(), 5, ' ', STR_PAD_BOTH));
            $output->write($columnsHeader);
        }

        $output->writeln('');
        $output->writeln($rowBorder);

        $blankRow = str_repeat('     |', count($cols) + 1);
        foreach ($board->getRows() as $row) {
            $output->writeln($blankRow);
            $rowHeader = sprintf('%s|', str_pad((string)$row->getNumber(), 5, ' ', STR_PAD_BOTH));
            $output->write($rowHeader);
            foreach ($row->getTiles() as $tile) {
                $coords = $tile->getCoordinates();
                if ($tile->hasCastle()) {
                    $castleArmyValue = str_pad((string)$tile->getCastle()->getArmy()->count(), 3, ' ', STR_PAD_BOTH);
                    $output->write(sprintf('[%s]|', $castleArmyValue));
                } else {
                    $output->write('     |');
                }
            }
            $output->writeln('');
            $output->writeln($blankRow);
            $output->writeln($rowBorder);
        }
    }

    private function doNextMove(Game $game, OutputInterface $output, InputInterface $input)
    {
        /**@var QuestionHelper $questionHelper */
        $questionHelper = $this->getHelper('question');

        $activePlayer = $game->getActivePlayer();
        $questionHelper->ask($input, $output, new ConfirmationQuestion('Throw dices, player ' . $activePlayer->getId()));

        $availableActions = [
            'spawn',
        ];
        $movablePlayerArmiesCoordinates = $this->collectMoveblePlayerArmiesCoordinates($game->getBoard(), $activePlayer);
        if (count($movablePlayerArmiesCoordinates)) {
            $availableActions[] = 'move';
        }

        $choice = $questionHelper->ask($input, $output, new ChoiceQuestion('What will you do?', $availableActions));
        switch ($choice) {
            case 'spawn':
                $castlesCoords = [];
                foreach ($game->getBoard()->getTiles() as $tile) {
                    if ($tile->hasCastle() && $tile->getCastle()->getOwner() === $activePlayer) {
                        $castlesCoords[] = $tile->getCoordinates();
                    }
                }
                $coords = $questionHelper->ask($input, $output, new ChoiceQuestion('Choice castle for replenish', $castlesCoords));
                $action = new ReplenishGarrison($game->getBoard()->getTileByCoordinates($coords)->getArmy());
                break;
            case 'move':
                $coords = $questionHelper->ask($input, $output, new ChoiceQuestion('Choice army for moving', $movablePlayerArmiesCoordinates));
                $nearestTiles = [];
                $sourceTile = $game->getBoard()->getTileByCoordinates($coords);
                foreach ($sourceTile->getNearestTiles() as $tile) {
                    $nearestTiles[] = $tile->getCoordinates();
                }
                $targetCoords = $questionHelper->ask($input, $output, new ChoiceQuestion('Choice target tile', $nearestTiles));
                $targetTile = $game->getBoard()->getTileByCoordinates($targetCoords);

                $units = $questionHelper->ask($input, $output, new Question('Enter number of units for moving [1-' . $sourceTile->getArmy()->count() . ']'));

                $action = new MoveArmy($sourceTile, $targetTile, $units);
                break;
            case 'divide':
                break;
        }

        $game->invoke($action);
    }

    private function collectMoveblePlayerArmiesCoordinates(Board $board, PlayerInterface $activePlayer): array
    {
        $armies = [];
        foreach ($board->getTiles() as $tile) {
            if ($tile->hasArmy() && $tile->getArmy()->getOwner() === $activePlayer) {
                if ($tile->hasArmy() && $tile->getArmy()->count() === 1) {
                    continue;
                }
                $armies[] = $tile->getCoordinates();
            }
        }

        return $armies;
    }
}

